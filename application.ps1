$Time1 = Get-Date
#gathering data from the local device via the registry, the most complete source for application informatio, I have chosen this as the source as it is the easist location for a "beginner" to access, e.g. the control panel.
$applications = Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, quietuninstallstring
$count=0
$unique=0





#specifying the file I wish data to be written to and removing any previous versions of the file.
$outfile = "$pwd\application_vuln.csv"


#iterating through the data found within the "applications" variable for furhter use below.
$applications | ForEach-Object ($_) {

#Declaring and returning the value to 0 for each new "application"
$appsfound = 0

#getting a value from the User interface, which is utiltised to speicfy the number of vulnerabilties the user wants per application.
$value=Get-Content $pwd\default\value.txt

#creating a variable which contains the display name of the current application and then removing commas from that data.
$check = $applications[$count].DisplayName
$check = $check -replace ' ','+'

#visual output for the user to display which application the scanner is currently checking if they use the show power shell option.
Write-Host $check


#specifying the URL address and the application name, which generates web pages that the application can utitlise for web scraping
$html = Invoke-WebRequest -Uri "https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=$check"

#turning each returned cve into an object for further manipulation, this is gathered from the above specified webpages, which have been web scraped for data.
$output = $html.Links | ForEach-Object -MemberName innertext | Select-String "CVE-"


#addressing each returned CVE as its own object for manipulation and further web scraping.
#this also grants the ability to ignore applications that do not have any false positives or positives assoicated with them, as it will have nothing to grab
    foreach ($_ in $output) {


    #an if statement that enforces the pre-defined value from the user, e.g. this will stop at 2 vulnerabilties per application if the user specified 2 as the value.
        if ($appsfound -lt $value) {
            

            #writing out each member of the object as a string that can be utilised by PS
            $CVE = $_


            #declaring and replacing some values that would cause issues within the "database", csv file.
            $publisher = $applications[$count].Publisher -replace ','+ ' '
            $appV = $applications[$count].Displayversion
            if ($appv.length -lt 1 ){
            $appv = "Unknown"}
            $appname =  $applications[$count].DisplayName -replace ','


            
            #utilising the previous CVE, to generate new web pages, within which the comment or text is scraped from. there is some data validation here aswell, removing characters that would casue issues.
            $html2 = Invoke-WebRequest -Uri "https://nvd.nist.gov/vuln/search/results?form_type=Basic&results_type=overview&query=$CVE" 
            $output2 = $html2.ParsedHtml.all.tags("td") | ForEach-Object -MemberName innertext | Select-Object -First 1
            $output2 = $output2 -replace ',' + ' '
            #this is one of the more tedious aspects of the code and took awhile to figure out, this is spilitting the comment data from the publish date and CVE risk values,
            #this resulted in a stray double quotation mark which had to be resolved further down the line. Could not trim the end for some strange reason as it was being viewed asa new line.
            $output2 = $output2 -split "Published:" | Select-Object -First 1
            
            #web scraping the Risk value from a different web page that was easier to scrap data from, simply less manipulation of data had to occur, which increases performance. 
            $html3 = Invoke-WebRequest -Uri "https://nvd.nist.gov/vuln/detail/$CVE"
            $output3 = $html3.ParsedHtml.getElementById("Cvss3NistCalculatorAnchor") | ForEach-Object -MemberName innertext

            #a simple if statement to determine if a risk value has been found or not, if not it simply places undetermined in its place.
            if ($output3.length -eq 0 )  {$output3 = "Undetermined"}

           

            

            #custom object which exports data to a csv file for use external to this script.
            if ($applications[$count].DisplayName -gt 3) {
                    [pscustomobject]@{
                    unique_value = $unique++
                    App_Name =   $appname
                    App_Version =$appV
                    CVE = $cve
                    Publisher = $publisher
                    Risk = $output3
                    Comment = $output2

                    } | export-csv -NoTypeInfo -Path $outfile -Append 
            }
                else {break}
            $appsfound++
        }
        else {break}

    }

$count++
} 

#removing the value text file, which is previously created from interaction with the UI, cleaning up the directory within which it will be placed.
#this has been removed so that the user may set default settings for their next scan.
#Remove-Item $pwd\value.txt -Force

#removing the previously mentioned double quotation mark that was resulting in issues.
#this was done by creating a new file and copying over the content to it, deleting the original and then renaming the new file to the previous. The user does not see this occur. 
$i = 1
Get-Content $outfile | Where-Object { $i % 2 -eq 0; $i++ } | Add-Content "application_vuln_clean.csv"
Remove-Item $outfile -Force
rename-item "application_vuln_clean.csv" -newname "application_vuln.csv"
$Time2 = Get-Date
$Time3 = $Time2 - $Time1
Write-Host $Time3